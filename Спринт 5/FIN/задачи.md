a. Пирамидальная сортировка
В данной задаче необходимо реализовать сортировку кучей. При этом кучу необходимо реализовать самостоятельно, использовать имеющиеся в языке реализации нельзя. Сначала рекомендуется решить задачи про просеивание вниз и вверх.

Тимофей решил организовать соревнование по спортивному программированию, чтобы найти талантливых стажёров. Задачи подобраны, участники зарегистрированы, тесты написаны. Осталось придумать, как в конце соревнования будет определяться победитель.
Каждый участник имеет уникальный логин. Когда соревнование закончится, к нему будут привязаны два показателя: количество решённых задач Pi и размер штрафа Fi​

Штраф начисляется за неудачные попытки и время, затраченное на задачу.
Тимофей решил сортировать таблицу результатов следующим образом: при сравнении двух участников выше будет идти тот, у которого решено больше задач. При равенстве числа решённых задач первым идёт участник с меньшим штрафом. Если же и штрафы совпадают, то первым будет тот, у которого логин идёт раньше в алфавитном (лексикографическом) порядке.
Тимофей заказал толстовки для победителей и накануне поехал за ними в магазин. В своё отсутствие он поручил вам реализовать алгоритм сортировки кучей (англ. Heapsort) для таблицы результатов.

Формат ввода 1≤n≤100000.
В каждой из следующих n строк задана информация про одного из участников.
i-й участник описывается тремя параметрами:

уникальным логином (строкой из маленьких латинских букв длиной не более 20)
числом решённых задач Pi
​штрафом Fi
Fi и Pi — целые числа, лежащие в диапазоне от 0 до 10 ^9.

Формат вывода
Для отсортированного списка участников выведите по порядку их логины по одному в строке.

b.Удали узел
Дано бинарное дерево поиска, в котором хранятся ключи. Ключи — уникальные целые числа. Найдите вершину с заданным ключом и удалите её из дерева так, чтобы дерево осталось корректным бинарным деревом поиска. Если ключа в дереве нет, то изменять дерево не надо.

На вход вашей функции подаётся корень дерева и ключ, который надо удалить. Функция должна вернуть корень изменённого дерева. Сложность удаления узла должна составлять
O(h), где h –— высота дерева.

Создавать новые вершины (вдруг очень захочется) нельзя.

Используйте заготовки кода для данной задачи, расположенные по ссылкам: https://github.com/Yandex-Practicum/algorithms-templates/blob/main/js/sprint5_final/B/code.js
Формат ввода
Ключи дерева – натуральные числа, не превышающие 10^9. В итоговом решении не надо определять свою структуру/свой класс, описывающий вершину дерева.

Вы можете ознакомиться с инструкцией по работе с Make на платформе в разделе "Начало", тема «Введение в алгоритмы», урок «Оптимизация ввода и вывода»

Формат вывода
По умолчанию выбран компилятор Make. Решение нужно отправлять в виде файла с расширением, которое соответствует вашему языку программирования. Если вы пишете на Java, имя файла должно быть Solution.java, для C# – Solution.cs. Для остальных языков назовите файл my_solution.ext, заменив ext на необходимое расширение.
