/*
1. ОТЧЕТ  https://admin.contest.yandex.ru/submissions/138882835

2. ПРИНЦИП РАБОТЫ
На вход подается корень бинарного дерева и индекс элемента, который нужно удалить.
Сначала проверяем что корень дерева существует, если нет - возвращаем null.
Далее ищем узел, который нужно удалить, если он меньше текущего узла, ищем в левом поддереве, если больше - в правом
    
Если узел с нужным ключом был найдет, рассматриваем три варианта:
 1. если у узла нет детей, просто удаляем узел, возвращая null вместо него
 2. если есть один ребенок, возвращаем ссылку на одного ребенка вместо него 
 3. если два ребенка, находим минимальное значение в правом поддереве, заменяем значение текущего узла на найденное минимальное, рекурсивно удаляем минимальный узел из правого поддерева

3. ДОКАЗАТЕЛЬСТВО КОРРЕКТНОСТИ
Алгоритм считаем корректным, потому что в нем реализованы базовые случаи для выхода из рекурсий
- во входных данных нет деревва (передается null)
- каждый рекурсивный вызов обрабатывает выбранное поддерево
Для удаления рассмотрены все возможные случаи:
    1. Если удаляется лист дерева (нет детей), мы просто удаляем конечный узел, при этом не нарушая свойства бинарного дерева поиска
    2. Если удаляется узел, у которого один ребенок - ребенок заменяет собой родителя, при этом все его связи "вниз" не затрагиваются, что приводит к тому, что свойства бинарного дерева поиска не нарушаются
    3. Если удаляется узел с двумя детьми, то мы ищем минимальный узел в правом поддереве, при этом этот узел гарантированно больше всех значений в левом поддереве, если опираться на свойства бинарного дерева поиска, а значит при замене таким узлом удялемого корня, свойства не будут быть нарушены. Рекурсивное удаление минимального узла сводится к одному из вышеописанных кейсов.

4. ВРЕМЕННАЯ СЛОЖНОСТЬ
Поиск удаляемого узла в худшем случае нужно пройти от корня до листа за O(h)
Поиск минимального элемента в правом поддереве (для случая с двумя детьми), в худшем случае нужно спуститься до самого левого листа правого поддерева за O(h) 
Рекурсивное удаление минимального узла за O(h) 
Общая временная сложность алгоритма составляет O(h).
В худшем случае, когда дерево превращается в связный список, h = n, где n - количество узлов в дереве. В сбалансированном дереве h = log(n).

5. ПРОСТРАНСТВЕННАЯ СЛОЖНОСТЬ
Входные данные = O(n), где n- количество элементов в дереве, ключ - O(1)
Для поиска минимального значения в правом поддереве используется переменная, которая занимает O(1)
Рекурсивные вызовы функции создают стек вызовов глубиной O(h), где h - высота дерева

Таким образом, общая пространственная сложность алгоритма составляет O(h)
В худшем случае (дерево превращается в связный список) - O(n)
В сбалансированном дереве - O(log n)

*/
if (process.env.REMOTE_JUDGE !== "true") {
  class Node {
    constructor(value, left = null, right = null) {
      this.value = value;
      this.left = left;
      this.right = right;
    }
  }
}

function remove(node, key) {
  if (node === null) {
    return null;
  }

  if (key < node.value) {
    node.left = remove(node.left, key);
    return node;
  }

  if (key > node.value) {
    node.right = remove(node.right, key);
    return node;
  }

  if (node.left === null && node.right === null) {
    return null;
  }
  if (node.left === null) {
    return node.right;
  }
  if (node.right === null) {
    return node.left;
  }

  let minElement = node.right;
  while (minElement.left) {
    minElement = minElement.left;
  }

  node.value = minElement.value;
  node.right = remove(node.right, minElement.value);

  return node;
}

function test() {
  var node1 = new Node(2, null, null);
  var node2 = new Node(3, node1, null);
  var node3 = new Node(1, null, node2);
  var node4 = new Node(6, null, null);
  var node5 = new Node(8, node4, null);
  var node6 = new Node(10, node5, null);
  var node7 = new Node(5, node3, node6);
  var newHead = remove(node7, 10);
  console.assert(newHead.value === 5);
  console.assert(newHead.right === node5);
  console.assert(newHead.right.value === 8);
}
