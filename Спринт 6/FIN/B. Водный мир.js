/*
1. ОТЧЕТ https://contest.yandex.ru/contest/25070/run-report/139469198/

2. ПРИНЦИП РАБОТЫ
Я использую обход графа в ширину для поиска всех клеточек, которые имеют связь с другими (самого большого острова), заканчивая каждый остров, я обновляю максимальный размер острова и количество островов. 
Используем массив смещений directions, для того, чтобы проверять каждое направление от клетки.

Проходим по матрице островов, проверяем, если клетка не посещена еще и является землей, запускаем от нее поиск в ширину (BFC).
Поиск в ширину (BFC) происходит следующим образом: 
- берем вершину, с которой была вызвана функция, помечаем ее как посещенную, создаем очередь для поиска в ширину (BFC) и кладем туда эту вершину
- пока очередь не пуска, проверяем:
  - берем вершину из очереди, для каждой из ее 4х сторон проверяем, не вышли ли мы за границы карты, посещена ли эта точка, является ли она землей.
  - если проверка пройдена, добавляем ее в очередь и помечаем как посещенную, увеличиваем размер текущего острова. 

  По результатам выполнения поиска в ширину (BFC) возвращаем полученный размер острова.
  В случае, если он больше текущего максимального значения - обновляем максимум, обновляем количество островов.

  Далее переходим к следующей точке на карте, если она не является посещенной, значит - это начало нового острова и опять запускаем поиск в ширину (BFC) для нее.


3. ДОКАЗАТЕЛЬСТВО КОРРЕКТНОСТИ
- так как остров имеет связку только по горизонтали и по вертикали, проверки с четырех сторон, с условиями невыхода из острова достаточно для корректного подсчета острова.
- цикл в цикле прохода по всем точкам позволяет проверить всю карту, при этом есть проверка на посещенность точки, что позволяет избежать лишних вызовов и запусков поиска в ширину (BFC).
- отмечание "посещенными" точек позволяет не считать их дважды, поэтому каждая найденная непосещенная клетка является началом нового острова.
- внутри  BFC обновляется счетчик размера каждый раз, когда посещается новая клетка острова, каждая клетка в цикле BFC проверяется только один раз, поэтому размер острова подсчитывается корректно.
- после завершения BFC каждый раз сверяется максимальный размер острова, и обновляется при необходимости


4. ВРЕМЕННАЯ СЛОЖНОСТЬ
  Каждая клетка карты n*m обрабатывается единожды O(N*M)
  Для каждой клетки выполняется поиск по четырем направлениям, плюс отметка о посещенности, это константные операции, 5*O(1)~O(1)
  Можем судить о том, что общая сложность алгоритма O(N*M)

5. ПРОСТРАНСТВЕННАЯ СЛОЖНОСТЬ
  Хранение карты - O(N*M) памяти
  Хранение переменной о кол-ве островов O(1)
  Хранение переменной о максимальном размере O(1)
  Хранение направлений O(1)
  Массив посещенности O(N*M)
  Очередь для BFC может занимать до O(N*М) в худшем случае (вся карта = остров)

  Общая сложность 2*O(N*M)~O(N*M)
*/

const _readline = require("readline");

const _reader = _readline.createInterface({
  input: process.stdin,
});

const inputLines = [];
let curLine = 0;

_reader.on("line", (line) => {
  inputLines.push(line);
});

process.stdin.on("end", solve);

const getMaxSize = (arr, n, m) => {
  const visited = Array.from({ length: n }, () => Array(m).fill(false));
  let islands = 0;
  let maxSize = 0;

  const directions = [
    [0, 1], // вправо
    [1, 0], // вниз
    [0, -1], // влево
    [-1, 0], // вверх
  ];

  const bfs = (startI, startJ) => {
    let queue = [[startI, startJ]];
    visited[startI][startJ] = true;
    let size = 1;
    while (queue.length > 0) {
      const [i, j] = queue.shift();
      for (const [di, dj] of directions) {
        const ni = i + di;
        const nj = j + dj;
        if (
          ni >= 0 &&
          ni < n &&
          nj >= 0 &&
          nj < m &&
          !visited[ni][nj] &&
          arr[ni][nj] === "#"
        ) {
          visited[ni][nj] = true;
          queue.push([ni, nj]);
          size++;
        }
      }
    }
    return size;
  };

  for (let i = 0; i < n; i++) {
    for (let j = 0; j < m; j++) {
      if (arr[i][j] === "#" && !visited[i][j]) {
        islands++;
        const size = bfs(i, j);
        if (size > maxSize) maxSize = size;
      }
    }
  }
  return [islands, maxSize];
};

function solve() {
  const counters = readLine();
  const [n, m] = counters.split(" ").map(Number);
  const list = readArray(m);
  const result = getMaxSize(list, n, m);
  process.stdout.write(result.join(" ").toString());
}

function readInt() {
  const n = Number(inputLines[curLine]);
  curLine++;
  return n;
}
function readLine() {
  const line = inputLines[curLine];
  curLine++;
  return line;
}

function readArray(counter) {
  const arr = [];
  for (let i = 0; i < counter; i++) {
    arr.push(inputLines[curLine++]);
  }
  return arr;
}
