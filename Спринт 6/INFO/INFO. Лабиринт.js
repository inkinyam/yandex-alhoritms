/*
# Заведём функцию, которая будет проверять выход за границу поля и наличие
# в клетке препятствия.
def is_free(point):
  x, y = point
    return x >= 0 and y >= 0 and x < n and y < m and field[x][y] == 0

# Функция проверяет, является ли точка выходом из лабиринта.
def is_exit(point):
  x, y = point
  return is_free(point) and (x == n - 1 or x == 0 or y == m - 1 or y == 0)

# Чтобы не копировать один и тот же код,  
# сделаем массив с векторами возможных перемещений.
movements = [(0, 1), (0, -1), (1, 0), (-1, 0)]

# Сложение нужно для удобного передвижения из точки на вектор передвижения.
# Другой вариант -- определить свой класс для точки и 
# переопределить в нём сложение.
def add(point1, point2):
  return (point1[0] + point2[0], point1[1] + point2[1])

# Так выглядит обход соседей текущей клетки point=(x, y).
for move in movements:
  new_point = add(point, move)
  if is_free(new_point):
    do_something(new_point) 
*/
// Считываются размеры поля и сама карта.

const [n, m] = [1, 3]; // Число строк и столбцов в карте.
const field = [[1, 3, 4], [2, 3, 4], ...[1, 2, 3]]; // Считываем саму карту.
const startPoint = [1, 2]; // Найдём стартовую клетку, в которой стоит звёздочка.

/*
Заметим, что наш граф — неориентированный и невзвешенный. Тогда для решения этой задачи можно использовать обход в ширину. Запустим BFS из начальной вершины и закончим обход в тот момент, когда впервые наткнёмся на выход из лабиринта. Попутно будем хранить расстояния до посещённых вершин.

Как лучше хранить граф в такой задаче? Можно просто построить граф, где рёбра будут явно проведены между соседними свободными клетками. Сделать это достаточно легко, но мы потратим лишнюю память. А можно хранить граф в неявном виде — ведь у нас есть карта лабиринта. Находясь при обходе в точке с координатами i и j, мы сможем проверить возможность перехода в каждую из соседних клеток.
*/
function escapeFromMaze(n, m, field, start_point) {
  // Предок вершины (x, y) -- это предыдущая вершина на кратчайшем пути
  // от стартовой точки до текущей (x, y).
  // Изначально заполняем любыми невалидными значениями, например, None или -1.
  const prev = new Array(n).fill(new Array(m).fill(-1));

  // Заполняем массив расстояний нейтральными по отношению к минимуму значениями.
  // Значение x нейтральное, если min(x, y) = y для любого допустимого y.
  const INF = n * m + 10;
  const dist = new Array(n).fill(new Array(m).fill(-1));

  // Начинаем обход в ширину (BFS).
  // Заведём очередь, поддерживающую операции push и pop.
  const q = new Queue();

  q.push(startPoint);
  while (q.length > 0) {
    const current_point = q.pop();
    for (let move of movements) {
      const newPoint = add(currentPoint, move);
      if (isFree(newPoint) && dist[newPoint] === INF) {
        q.push(newPoint);
        prev[newPoint] = currentPoint;
        dist[newPoint] = dist[current_point] + 1;
        if (isExit(newPoint)) {
          return [dist[newPoint], newPoint];
        }
      }
    }
  }

  return [INF, [-1, -1]];
}

/*
В конце, если выхода не нашлось, то вернём условную бесконечность, так как выйти из лабиринта за конечное число шагов нельзя. В качестве бесконечно большого значения можно взять такое число шагов, которое гарантированно больше любого возможного ответа. INF можно присвоить любое значение больше n∗m, так как каждую клетку разумно посещать не более одного раза, а всего клеток на прямоугольном поле n∗m.
Теперь попробуем восстановить путь из стартовой точки до выхода — для этого будем использовать построенный ранее массив предков.
*/

// Вызываем функцию поиска пути
const [dist, currentPoint] = escapeFromMaze(n, m, field, startPoint);
const path = [];

// Строим путь от текущей точки до стартовой точки
while (!isEqual(currentPoint, startPoint)) {
  path.push(currentPoint);
  currentPoint = prev[currentPoint];
}

// Условие выхода из цикла составлено так, что начальная точка не будет добавлена в путь, поправим это.
path.push(startPoint);

// Разворачиваем путь, так как первой мы добавляли конечную точку маршрута.
path.reverse();
