/*
Отчет: https://contest.yandex.ru/contest/22781/run-report/136349585/
Отчет v2: https://contest.yandex.ru/contest/22781/run-report/136428246/

ПРИНЦИП РАБОТЫ
функция принимает строку со значениями на вход, которую мы разбиваем на массив значений, в связи с тем, что нам не нужен мутированный массив, использую forEach вместо map
для каждого значения в массиве проверяем является ли элемент знаком операции (включен в массив OPERATIONS), выполняем следующие действия:
  - достаем последнее добавленное число (firstNumber)
  - достаем предпоследнее добавленное число (secondNumber)
  - вызываем функцию useOperation в которую передаем операцию и числа в порядке добавления в очередь
  - добавляем в очередь результат работы функции useOperation
в противном случае добавляем в очередь число (т.к. в массиве у нас строки, для упрощения работы переводим их при добавлении в число)
так как в очереди может быть больше чем 1 значение (не со всеми числами выполнены операции), возвращаем последнее число в очереди

ДОКАЗАТЕЛЬСТВО КОРРЕКТНОСТИ
Из описания алгоритма следует, что при добавлении очередного значения на вход, с ним будет выполняться действие : добавление в очередь или выполнение калькуляционного действия (сложение, умножение, вычитание, деление), при этом при выполнении калькуляционной операции из очереди вынимаются два последних добавленных числа и с ними выполняется действие, которое пришло в значении.
Важно: не реализована проверка на значение, которое не является числом или другим калькуляционным действием.

ВРЕМЕННАЯ СЛОЖНОСТЬ
Добавление в очередь  стоит по времени О(1), т.к. добавление всегда происходит в конец очереди.
Извлечение из очереди так же стоит О(1), т.к. извлекается всегда последний элемент очереди.
Оценим выполнение действий при входной строке в n символов:
- каждый элемент в очереди будет добавлен и удален из нее 1 раз
- на выполнение действия с двумя элементами требуется:
    - извлечение из очереди элемента О(1)
    - извлечение из очереди элемента О(1)
    - выполнение действия с двумя элементами О(1)
    - добавление в очередь результата О(1)
    - итого выполнение действия 4*О(1) ~ O(1)
В связи вышеперечисленным, считаем что для n входных данных, выполнение займет O(n)

ПРОСТРАНСТВЕННАЯ СЛОЖНОСТЬ
Очередь содержит n элементов, из которых m элементов - это операнды действий. Поэтому в худшем случае очередь будет занимать O((n-m)/2) (n элементов минус m операндов, и тк для выполнения операции нужно 2 элемента (которые в результате возвращают одно значение), делим пополам)

Также я храню в массиве n элементов, с которыми взаимодействую, соответственно они занимают  О(n) памяти 
Итого решение задачи будет занимать O(n) + O(n) = O(n) памяти
*/

var readline = require("readline");
var ioInterface = readline.createInterface({ input: process.stdin });

const inputLines = [];
let curLine = 0;

ioInterface.on("line", (line) => {
  inputLines.push(line);
});

process.stdin.on("end", solve);

class Stack {
  constructor() {
    this.items = [];
  }
  push(item) {
    this.items.push(item);
  }

  pop() {
    return this.items.pop();
  }
}

const Operations = {
  "+": (a, b) => a + b,
  "-": (a, b) => a - b,
  "*": (a, b) => a * b,
  "/": (a, b) => Math.floor(a / b),
};

const Errors = {
  no_operation: "Error: Операция не найдена",
};

const useOperation = (operation, number1, number2) => {
  if (operation in Operations) {
    return Operations[operation](number1, number2);
  } else return Errors.no_operation;
};

function solution(tokens) {
  let stack = new Stack();
  tokens.split(" ").forEach((item) => {
    if (Object.keys(Operations).includes(item)) {
      const firstNumber = stack.pop();
      const secondNumber = stack.pop();

      const result = useOperation(item, secondNumber, firstNumber);
      stack.push(result);
    } else {
      stack.push(Number(item));
    }
  });
  return stack.pop();
}

function solve() {
  const command = readLine();
  process.stdout.write(`${solution(command)}`);
}

function readLine() {
  const line = inputLines[curLine];
  curLine++;
  return line;
}
