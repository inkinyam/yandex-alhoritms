/*
1. ОТЧЕТ https://contest.yandex.ru/contest/24414/run-report/138179924/

2. ПРИНЦИП РАБОТЫ И ДОКАЗАТЕЛЬСТВО КОРРЕКТНОСТИ
На вход подается список команд, которые необходимо выполнить. Проходим циклом по массиву команд, разделяем команду на составляющие с помощью декомпозиции, с помощью структуры switch/case выполняем команду, в случае, если команда выбросила Error, вставляем в результат None (по условию задачи).

Хэш таблицу реализовала классом HashTable,в которой хранится массив "корзинок" в количестве 10^5+1 (ближайшее простое число к заданному размеру в задаче).
Так как я решила использовать метод цепочек для разрешения коллизий, я использую в качестве каждой корзины массив значений [key, value], при этом изначально я не заполняю каждую корзину пустым массивом, чтобы минимизировать изначально занятое место.

У класса реализованы методы:
1. getHash:Получить хэш ключа. Использовала функцию hash(h) = (h*{число Дональта Кнута} +размер таблицы)по модулю размера таблицы. Данная функция позволяет использовать в качестве h положительные и отрицательные значения, а также является достаточно быстрой для вычисления.

2. put: положить в корзину:
Метод выполняет вычисление номера корзины с помощью метода getHash, описанного выше. Далее в случае, если корзина еще отсутствует, мы ее создаем в виде массива и первым элементом.
В случае, если в корзине что-то есть, кладем в нее следующий элемент.
Данный метод ничего не возвращает, т.к. этого не требует задача.

3. get: достать из корзины значение по ключу.
Метод вычисляет номер корзины с помощью метода getHash.
В случае, если корзина отсутствует, выдается ошибка об отсутствии корзины. 
В случае, если корзина найдена, выполняется поиск нужного элемента по ключу путем перебора всех находящихся в в корзине элементов.
Линейный поиск допустим, в связи с тем, что хеш-функция должна обеспечивать правильное заполнение таблицы.
Функция возвращает найденное значение или выбрасывает ошибку от отсутствии элемента.

4. delete: удалить элемент по ключу.
Метод вычисляет номер корзины с помощью метода getHash.
В случае, если корзина отсутствует, выдается ошибка об отсутствии корзины. 
В случае, если корзина найдена, выполняется поиск нужного элемента по ключу путем перебора всех находящихся в в корзине элементов.
Линейный поиск допустим, в связи с тем, что хеш-функция должна обеспечивать правильное заполнение таблицы.
Функция возвращает удаляет из корзины выбранный элемент и возвращает значение.
При отсутствии элемента выбрасывает ошибку об отсутствии элемента.


3. ВРЕМЕННАЯ СЛОЖНОСТЬ
1. Входные данные
Чтение массива команд занимает O(n) времени.

2. Выполнение команд.
Для того, чтобы выполнить все команды, необходимо пройти по каждой из n команд, что займет O(n) времени
Для каждой команды выполняются следующие действия:
- разделение на команду и значения для нее за O(1) времени
- выбор конкретной команды для таблицы O(1)времени
- выполнение конкретной команды
   - добавление элемента: в среднем - О(1), в худшем О(k), подробнее:
      - вычисление хеша О(1)
      - если корзина пустая - инициализация корзины О(1)
      - если корзина существует:
        - обновление ключа в среднем случае: О(1), если элемент немного, в худшем случае - O(k), где k- количество элементов в корзине, которые нужно перебрать
        - добавление ключа О(1) в конец (рехеширования нет, поэтому не рассматриваем худший случай, но он бы занял О(n))
    
    - получение элемента: в среднем - О(1), в худшем О(k), подробнее:
       - вычисление хеша О(1)
       - если корзина пустая - выдать ошибку О(1)
       - если корзина есть, перебрать все элементы:
          - в худшем случае О(к), где к - все элементы в корзине
          - в среднем - О(1)

    - удаление из корзины: В среднем О(1), в худшем - О(к)
       - вычисление хеша О(1)
       - если корзина пустая - выдать ошибку О(1)
       - если корзина существует:
         - поиск ключа в среднем случае: О(1), если элементов немного 1, в худшем случае - O(k), где k- количество элементов в корзине, которые нужно перебрать
         - выполнение перестановки удаляемого ключа с последним О(1) 
         - удаление последнего элемента из массива за О(1)

Итого, получается, что для выполнения всех действий в лучшем случае с учетом обработки вх.данных: 
    в худшем случае: O(n)*O(n)*O(k), где n- все команды, а k-общее кол-во элементов -  нам нужно прочитать все n команд(входные даннные), далее пройтись по каждой из n команд и выполнить необходимое действие с элементами, в случае, если в корзине k элементов, их сначала нужно перебрать, чтобы найти тот, с которым нужно выполнить действие, отсюда и получается n*n*k
    в среднем случае: О(n)*O(n)
без учета чтения данных, соответственно:
    в худшем случае: O(n)*O(k), где n- все команды, а k-общее кол-во элементов -тут тоже самое, без учета "прочитать n команд", пройтись по каждой команде, найти k-ый элемент, и выполнить действия.
    в среднем случае: O(n)


4. ПРОСТРАНСТВЕННАЯ СЛОЖНОСТЬ
- Хранение входных данных O(n), где n- количество команд
- Для хэш таблицы выделяется O(size)+ для хранения некоторых переменных O(1)на каждую (size, base, bucket)+О(m)
   где size = 100001,
       m = количество элементов в таблице, в среднем m<n(количества команд)
- Для хранения результатов выделено место под переменную  res, в среднем она будет меньше чем n, в связи с тем, что не все методы дают возвращаемый результат (метод put не требует возвращения результата добавления), учитываем, что под ответ выделено O(r) места.

Итого, под выполнение данного алгоритма используется O(n)+O(size+m)+O(r) памяти.
*/

const _readline = require("readline");

const _reader = _readline.createInterface({
  input: process.stdin,
});

const inputLines = [];
let curLine = 0;

_reader.on("line", (line) => {
  inputLines.push(line);
});

process.stdin.on("end", solve);

class ElementAbsentError extends Error {
  constructor() {
    super("Ошибка: Элемент отсутствует");
    this.name = "ElementAbsentError";
  }
}
class BucketAbsentError extends Error {
  constructor() {
    super("Ошибка: Корзина отсутствует");
    this.name = "BucketAbsentError";
  }
}

class HashTable {
  static ERRORS = "error";
  constructor(size = 100001) {
    this.table = new Array(size);
    this.size = size;
    this.base = 0.6180339887;
  }

  getHash(key) {
    return Math.floor(
      Math.abs(Number(key) * this.base + this.size) % this.size
    );
  }

  put(key, value) {
    const index = this.getHash(key);
    if (!this.table[index]) {
      this.table[index] = [];
    }
    const bucket = this.table[index];

    for (let b = 0; b < bucket.length; b++) {
      if (bucket[b][0] === key) {
        bucket[b][1] = value;
        return;
      }
    }

    bucket.push([key, value]);
  }

  get(key) {
    const index = this.getHash(key);
    const bucket = this.table[index];

    if (!bucket) throw new BucketAbsentError();

    for (const [k, v] of bucket) {
      if (k === key) {
        return v;
      }
    }

    throw new ElementAbsentError();
  }

  delete(key) {
    const index = this.getHash(key);
    const bucket = this.table[index];

    if (!bucket) throw new BucketAbsentError();
    for (let i = 0; i < bucket.length; i++) {
      if (bucket[i][0] === key) {
        const lastIndex = bucket.length - 1;
        [bucket[i], bucket[lastIndex]] = [bucket[lastIndex], bucket[i]];
        const deletedValue = bucket.pop()[1];
        return deletedValue;
      }
    }
    throw new ElementAbsentError();
  }
}

const handleHashOperations = (commands) => {
  let hashTable = new HashTable();
  const res = [];

  for (const commandStr of commands) {
    const [command, key, value] = commandStr.split(" ");
    switch (command) {
      case "get":
        try {
          res.push(hashTable.get(key));
        } catch (error) {
          res.push("None");
        }
        break;

      case "put":
        hashTable.put(key, value);
        break;

      case "delete":
        try {
          res.push(hashTable.delete(key));
        } catch (error) {
          res.push("None");
        }
        break;
    }
  }

  return res;
};

function solve() {
  const countQuery = readInt();
  const queries = readArray(countQuery);

  const result = handleHashOperations(queries);
  for (let i = 0; i < result.length; i++) {
    process.stdout.write(result[i]);
    process.stdout.write("\n");
  }
}

function readInt() {
  const n = Number(inputLines[curLine]);
  curLine++;
  return n;
}

function readArray(counter) {
  const arr = [];
  for (let i = 0; i < counter; i++) {
    arr.push(inputLines[curLine++]);
  }
  return arr;
}
