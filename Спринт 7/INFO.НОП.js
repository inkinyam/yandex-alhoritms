/*
 Нужно найти их самую длинную общую подпоследовательность. 
Например, для последовательностей {1,3,2,3,5,7} и {5,1,2,3,5,9,7} ответом будет {1,2,3,5,7}.


Рекурсивное решение
Попробуем решать эту задачу с конца. Рассмотрим самые правые символы в каждой строке: an   и bm  соответственно. 
Если они равны, значит НОП имеет длину как минимум 1. Отбрасываем последние символы в каждой строке и повторяем рассмотрение для двух получившихся после отбрасывания строк.
Если они не равны, то надо рассмотреть две подзадачи.
В первой подзадаче мы не берём последний символ строки b и ищем НОП строк a1 ,...,an  и b1 ,...b(m−1) , а во второй — не берём последний символ строки a и ищем НОП для строк a1,...,a(n−1)   и b1,...,bm​.
Так как мы ищем наибольшую общую подпоследовательность, то из результатов двух подзадач мы выберем максимальный.


Решение с помощью динамики
Что будет храниться в dp? В dp[i][j] будем хранить длину НОП для подстрок a[1:i] и b[1:j]. Такие подстроки называются префиксами. Будьте внимательны, нумерация индексов в непустых строках начинается не с 0, а с 1. 
Каким будет базовый случай для задачи? Как мы рассмотрели выше, если какая-то из строк пустая, то есть i=0 или j=0, то их НОП равна 0: dp[i][j]=0.
Каким будет переход динамики? В процессе перехода мы удлиняем одну из строк на один символ. 
Если до удлинения крайние символы в двух строках были равны и включены в НОП, то добавление нового символа не изменит длину НОП.
Иначе надо сравнить, не совпал ли новый символ с символом на конце второй строки. Если совпал, то увеличиваем НОП.
Каким будет порядок вычисления данных в массиве dp? Будем сначала считать, что строка a состоит из одного символа, а строка b постепенно удлиняется. Потом удлиняем строку a и снова перебираем все возможные длины b. 
Где будет располагаться ответ на исходный вопрос? Длина наибольшей общей подпоследовательности будет находиться в ячейке dp[N][M].
Рассмотрим работу этого алгоритма на примере строк A={b,t,t,a,d} и B={a,t,t,t,b,a}.

Восстановление ответа
Для того чтобы по таблице длин НОП получить наибольшую общую подпоследовательность, необходимо выполнить следующие действия:
1.Завести массив answer, в котором будет храниться НОП, записанная от конца к началу.
2.Начать с клетки dp[N][M]. Приравнять i к N, j к M.
3.Если A[i]=B[j], нужно записать в answer символ A[i] и переместиться в клетку dp[i−1][j−1]. Как мы говорили в начале урока, рассмотренный символ точно является частью НОП.
4.Если A[i] !=B[j], то один из символов в строках точно не входит в НОП.
-Если dp[i][j]=dp[i−1][j], значит, существует НОП, в которую A[i] точно не входит. Перемещаемся вверх — в соседнюю ячейку.
-Иначе — если dp[i][j]=dp[i][j−1], значит, существует НОП, в которую B[j] не входит. Перемещаемся в ячейку, расположенную левее текущей.

5.Повторяем пункты 3‒4 до тех пор, пока dp[i][j] !=0.
6.Переворачиваем массив answer и получаем наибольшую общую подпоследовательность.

Сложность алгоритма
В процессе заполнения мы обошли M⋅N клеток и в каждой из них вычислили результат за константное время. Следовательно, сложность построения таблицы dp  равна O(N⋅M).
Кроме того, для восстановления ответа мы сделали не более N шагов вверх по таблице и не более M шагов влево. Итого сложность восстановления НОП по массиву dp  равна O(N+M).
*/
