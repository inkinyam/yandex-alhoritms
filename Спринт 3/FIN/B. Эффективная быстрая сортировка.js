/*
1. ОТЧЕТ  
vol1. https://contest.yandex.ru/contest/23815/run-report/137291743/
vol2. https://contest.yandex.ru/contest/23815/run-report/137493857/

2. ПРИНЦИП РАБОТЫ
Реализовано несколько функций для реализации сортировки массива элементов по трём параметрам.
  1. Вспомогательная функция сравнения compareStudents, в которую передаются массивы с элементами данных по каждому ученику в формате [имя, количество задач, количество штрафов], и начинается сравнение элементов по параметрам в следующем порядке:
  - количество задач, если а>b, возвращается значение 1, что обозначает, что элементы стоят в корректном порядке, если a<b, возвращается значение, что элементы должны стоять в обратном порядке (а в ключе нашей основной задачи - элемент должен быть переставлен на позицию справа от pivot), если элементы равны, переходим к проверке по следующему параметру
  - количество штрафов, здесь проверка обратная, так как "выше" должен стоять элемент с меньшим количеством штрафов, если штрафы равны, то переходим к сравнению по имени
  - по условию имена участников всегда уникальные, но в функции реализован возврат ответа даже в случае, оба переданных элемента идентичны.

  2. Вспомогательная функция partition, которая принимает массив в текущей позиции, вычисленный "центральный" элемент, левый и правый индексы, которые ограничивают кусок массива, который необходимо сортировать функции.
  Функция выполняется, пока левый (leftIndex) и правый (rightIndex) индексы не сойдутся.
  Внутри основного цикла мы начинаем сначала проверять каждый элемент на то, что он меньше pivot (при условии, что левый индекс все еще меньше или равен правому). Если  все условия выполняются, мы передвигаем индекс вправо на один. Этим перебором мы находим первый индекс элемента слева, который должен находиться "с другой стороны" от pivot.
  Далее проводим ту же самую процедуру для элементов справа от pivot, чтобы найти первый элемент, который не подходит под условия.
  Когда мы нашли по элементу справа и слева, проверяем, что условие, что левый и правый индекс не "проскакали" друг друга, и меняем элементы местами. далее двигаем индексы дальше, чтобы цикл продолжился дальше до момента когда элементы сойдутся.
  После того, как элементы сойдутся, мы возвращаем индекс "середины" (я взяла левый), чтобы использовать его в основной функции сортировки в рекурсионном вызове.

  3. Основная функция getWinnerChart
  Данная функция принимает в себя следующие параметры: массив студентов, который сортируется на каждой итерации вызовов, левый и правый индексы, с которых сортировка.
  Обязательно проверяем, что границы не пересеклись (левая больше или равна правой), при пересечении возвращаем отсортированный массив.
  Далее ищем "опорный элемент", я всегда беру примерно середину массива (округляю).
  Далее получаем индекс для "деления" массива на более мелкие куски, вызывая функцию partition.
  Далее функция вызывает сама себя, при этом поделив условно массив на 2 части индексами. 
  - первая: это от left  элемента до полученного индекса из функции partition
  - вторая: от полученного индекса до right элемента переданного в функцию.

3. ДОКАЗАТЕЛЬСТВО КОРРЕКТНОСТИ
    Корректность функции compareStudents
    Функция реализует сравнение двух элементов в строгом порядке:
      -количество решенных задач
      -количество штрафов
      -логин(имя)
    Возвращает одно из значений: 0, 1 или -1.
    Даже если попались две совершенно идентичные строки, которых не должно быть по условию, функция вернет 0.
    
    Корректность функции partition
    Функция реализует разделение массива на две части относительно переданного опорного элемента. При этом не занимает дополнительной памяти на хранение новых массивов, а меняет местами элементы в текущем массив.
    На каждом этапе циклов стоят проверки, чтобы при пересечении левого и правого индексов, выполнение прекратилось.
    
    Корректность функции getWinnerChart
    Реализован с помощью рекурсии, которая требует обязательного базового случая для выхода из рекурсии, и он описан.
    В базовом случае массив уже отсортирован и возвращает этот массив на "уровень выше".
    
    На каждой итерации рекурсии выбирается опорный элемент из середины массива, с помощью вызова функции partition массив разделяется на две части с условием что слева - все элементы "выше по списку", справа - все элементы, которые должны быть ниже по списку.
    Далее вызывается эта же функция для каждой части массива.
    При этом на каждой итерации сортируемая часть массива уменьшается, что приводит к итогу к выполнению базового случая, что доказывает что ошибки бесконечного цикла рекурсий не может быть и выполнение всегда завершается.

4. ВРЕМЕННАЯ СЛОЖНОСТЬ
На чтение массива используется O(n) времени. Время зависит от размера массива, так как каждую строчку нужно считать отдельно.
В связи с тем, что я всегда выбираю за опорный элемент середину части массива, можно считать, что этим я снижаю вероятность худшего случая, при котором алгоритм будет проходить за O(n)*O(n) времени: Одна на выполнение рекурсивной части, вторая - на количество операций, что обозначает что пройдется дважды по массиву. 
Пример худшего случая: каждый раз опорный элемент является максимальным в массиве.
Так как мы пытаемся снизить вероятность худшего случая, надеемся, что алгоритм будет выполняться за время O(logN)*O(n), где O(logN) - рекурсивная часть, O(n) -количество операций на каждом "витке" рекурсии.

При этом можем рассмотреть время выполнения каждой функции отдельно:
  Функция compareStudents
  выполняется за O(1) времени, так как всегда выполняется фиксированное количество сравнений, каждое сравнение занимает O(1) времени, умножаем на количество сравнений(9), получается О(8), что также приводится к О(1)

  Функция partition
  Выполняется за O(n), так как каждый раз проходится по всем элементам части массива, который мы передаем на каждой итерации.

 Функции getWinnerChart
 Базовый случай выполняется за O(1)
 Рекурсивная часть выполняется за O(n)*O(logN) где:
 O(n) - время выполнения функции partition
 О(logN) - время выполнения всех уровней итерации

 Так как мы каждый раз делим массив пополам, получается, что уровней рекурсии будет O(logN)

5. ПРОСТРАНСТВЕННАЯ СЛОЖНОСТЬ
В связи с условиями задачи, мы были ограничены в доступной памяти для выполнения функции, в связи с чем, память расходуется максимально экономно.
У нас занято на входные данные O(n) памяти.

Алгоритм использует рекурсию для поиска в части массива. 
В связи с тем, что массив каждый раз при вызове функции делится пополам, занимает О(logN) памяти., помимо этого на каждом уровне рекурсии сохраняются параметры left и right, каждый занимает O(1) памяти.
Так как массив делится примерно пополам, глубина рекурсии составляет log Nю
Итого, получается что на каждый вызов занимает O(1)+O(1)+O(logN) памяти ~ O(logN)

Также, дополнительная память используется для хранения временных переменных внутри доп.функций partition и getWinnerChart.
Для функции  partition: переменные pivot, leftIndex, rightIndex, temp - O(4)~ O(1). Каждая переменная занимает константный размер памяти, потому что один элемент (pivot) занимает значительно небольшой объем памяти относительно всего массива, а индексы не могут превышать размер массива. Память освобождается, каждый раз после окончания выполнения функции.
Для функции getWinnerChart: переменная partitionIndex - O(1)

Таким образом, дополнительная память составляет O(log n) в среднем случае и O(n) в худшем случае (когда массив уже отсортирован и каждый раз pivot оказывается, например, максимальным элементом).
*/
var readline = require("readline");
var ioInterface = readline.createInterface({ input: process.stdin });

const inputLines = [];
let curLine = 0;

ioInterface.on("line", (line) => {
  inputLines.push(line);
});

process.stdin.on("end", solve);

function partition(array, pivot, leftIndex, rightIndex) {
  while (leftIndex <= rightIndex) {
    while (
      leftIndex <= rightIndex &&
      compareStudents(array[leftIndex], pivot) > 0
    ) {
      leftIndex++;
    }
    while (
      leftIndex <= rightIndex &&
      compareStudents(array[rightIndex], pivot) < 0
    ) {
      rightIndex--;
    }

    if (leftIndex <= rightIndex) {
      let temp = array[leftIndex];
      array[leftIndex] = array[rightIndex];
      array[rightIndex] = temp;
      leftIndex++;
      rightIndex--;
    }
  }
  return leftIndex;
}

const compareStudents = (a, b) => {
  //  hight -задачи, medium - штрафы, low - логины,
  const [low_a, hight_a, medium_a] = a;
  const [low_b, hight_b, medium_b] = b;

  if (Number(hight_a) !== Number(hight_b)) {
    return Number(hight_a) > Number(hight_b) ? 1 : -1;
  }

  if (Number(medium_a) !== Number(medium_b)) {
    return Number(medium_a) < Number(medium_b) ? 1 : -1;
  }

  if (low_a !== low_b) {
    return low_a > low_b ? -1 : 1;
  }

  return 0;
};

function quickSortInPlace(array, left = 0, right = array.length - 1) {
  if (left >= right) {
    return array;
  }

  let pivot = array[Math.floor((left + right) / 2)];
  let partitionIndex = partition(array, pivot, left, right);

  quickSortInPlace(array, left, partitionIndex - 1);
  quickSortInPlace(array, partitionIndex, right);

  return array;
}

function solve() {
  const count = readInt();
  const array = readArray(count);
  const result = quickSortInPlace(array);

  result.forEach((student) => {
    process.stdout.write(student[0]);
    process.stdout.write("\n");
  });
}

function readInt() {
  return Number(inputLines[curLine++]);
}

function readStr() {
  return inputLines[curLine++];
}

function readArray(counter) {
  const arr = [];
  for (let i = 0; i < counter; i++) {
    arr.push(inputLines[curLine++].split(" "));
  }
  return arr;
}
