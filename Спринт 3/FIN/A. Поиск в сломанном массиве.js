/*
1. ОТЧЕТ  https://contest.yandex.ru/contest/23815/run-report/137208149/

2. ПРИНЦИП РАБОТЫ
  Использую чуть модифицированный (для проверки сломанности массива) бинарный поиск без рекурсии.
  Объявляем переменные, которые будут отвечать за левую границу массива (left), правую границу массива (right), центр массива (middle) - по которому будем делить массив, и возвращаемый index.

  Проходимся циклом с условием, что пока левая граница меньше или равна правой, цикл выполняется.
  В нем мы производим следующие действия:
    - ищем середину массива заданного границами left и right от текущего.
    - проверяем, является ли выбранный центральный элемент тем, который мы ищем, если это он - записываем индекс middle в переменную index и прекращаем работу цикла.
    - далее смотрим, какая из частей поделенного массива "правильная"(отсортированная по возрастанию), для этого проверяем сначала левую часть на условие  значение левой границы меньше значения правой границы 
      - проверяем, входит ли искомый элемент в границы отсортированного массива при этом сравниваем левую сторону ВКЛЮЧИТЕЛЬНО, правую - нет (так как middle мы проверили выше)
        - если входит в границы, сдвигаем правую границу на уровень middle-1 , чтобы искать в левой части массива с изначальными границами left, right
        - если не входит, сдвигаем левую границу на уровень middle+1, чтобы искать в правой части массива с изначальными границами left, right
      - если искомый элемент не входит в границы левой части, проверяем правую на вхождение элемента в границы от середины до правой части (при этом проверяем на вхождение правую границу, с середину = нет)
         - если входит в границы, сдвигаем левую границу на уровень middle+1 , чтобы искать в левой части массива с изначальными границами left, right
        - если не входит, сдвигаем правую границу на уровень middle-1, чтобы искать в правой части массива с изначальными границами left, right
    -если нигде элемента не нашлось, возвращаем изначально заданный index = -1

3. ДОКАЗАТЕЛЬСТВО КОРРЕКТНОСТИ
    Исходя из написанного алгоритма видно, что мы проверяем мы проверяем все части массива, на которые его делим на нахождение в нем нужного нам элемента.
    Мы проверяем все крайние случаи входных данных:
     - элемент отсутствует в массиве - возвращается запрашиваемый в задаче ответ в таком случае
     - если массив состоит из одного элемента - мы проверяем его и сразу возвращаем ответ.
     - если массив пуст, мы также проверим его без ошибок и вернем ответ /не стала добавлять доп.проверку на длину массива, т.к. случай обрабатывается корректно/
     
    Движение по циклу прекращается при нахождении нужного элемента, не тратится дополнительное время на "доработку"

4. ВРЕМЕННАЯ СЛОЖНОСТЬ
Поиск работает за O(logN) итераций, так как каждый раз происходит деление массива поиска пополам.
При этом выполняются простые операции:
1) вычисление середины массива , занимает O(1) времени
2) сравнение элемента с индексом middle с k , занимает O(1) времени
3) далее все сравнения и проверки также занимают  O(1) времени
4) перезаписывание элемента left, right, index = занимают также O(1) времени
Итого по всем операциям O(1) времени.

Получается что по всем итерациям мы выполняем O(logN)*O(1) времени, что ~ O(logN) времени на выполнение всего алгоритма.


5. ПРОСТРАНСТВЕННАЯ СЛОЖНОСТЬ
Так как элементов в массиве может быть неограниченное количество, считаем, что исходный массив займет O(N) памяти + О(1) памяти на элемент, который ищется.
Для хранения переменных left, right, index, middle также используется O(1) места. 
При поиске не создается дополнительных переменных и массивов, что обозначает, что дополнительно память не занимается.

Итого получается, что всего памяти будет занято: O(N)+O(1)+O(1)+O(1)+O(1)+O(1)=O(N)+O(5)~O(N)
Считаю, что размер массива значительно больше любого из чисел внутри него и тем более значений индексов данного массива, в связи с этим константные значения можно опустить, и в целом считать, что пространства данный алгоритм занимает примерно с размер входного массива.
*/

function brokenSearch(arr, k) {
  let left = 0;
  let right = arr.length - 1;
  let index = -1;

  while (left <= right) {
    const middle = Math.floor((left + right) / 2);

    if (arr[middle] === k) {
      index = middle;
      break;
    }

    if (arr[left] <= arr[middle]) {
      if (arr[left] <= k && k < arr[middle]) {
        right = middle - 1;
      } else {
        left = middle + 1;
      }
    } else {
      if (arr[middle] < k && k <= arr[right]) {
        left = middle + 1;
      } else {
        right = middle - 1;
      }
    }
  }

  return index;
}
